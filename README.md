#单元测试方案参考

---
###一 、样例项目说明

        样例项目抽取了spring cloud项目中一个模块的少许方法。无需成功启动项目，只需跑测单元测试。
        项目由maven做依赖管理，api模块采用java 8，service模块采用java 11。
        涉及外部依赖需要mock的为：微信接口调用、配置文件读取、mysql数据库操作。

---
###二 、选型

         测试框架采用：junit 5.5.2   +    mockito 3.1.0    +  jmockit 1.49

         说明：

                  1. 采用junit 5.x原因为相比4.x利用了Java 8或更高版本的特性，并支持嵌套测试以及添加描述注解有助于理解测试报告。

                  2. 采用mockito则因为它是最热门的mock框架。

                  3. 采用jmockit两个原因。第一、mockito不支持静态方法mock，需要依赖动态操作字节码的mock框架，第二、相比jmockit更火的powerMock不支持junit 5+。

---
###三 、规范


          1.  通过一次只测试一个业务路径来保持单个测试的简单性。如果只有一条路径的测试失败，则更容易找到错误并纠正它。较短的测试也更容易阅读和维护，更容易作为新测试的构建块重用。

          2.  测试边角案例非常重要，可以验证它们是否被发现。要特别注意错误条件和异常情况，因为它们通常在单元测试期间比在后面的测试阶段更容易模拟。

          3.  单元测试应该是可重复执行的，并且独立于执行它们的运行时环境。不应该依赖于外部系统，如数据库或容器(web服务器、应用服务器)。

          4.  在设计和构建代码时考虑可测试性。遵循设计最佳实践，如“对接口编程”或“依赖注入”，因为这些惯例可能会产生容易测试的代码。

          5.  当一个缺陷被报告，并无法立马找到问题时，马上为它写一个测试用例。

          6.  一个好的规则是从testXxx命名方案开始，其中Xxx是要测试的方法的名称。当您针对同一方法添加其他测试时，请使用testXxxWithYyy方案，其中Yyy描述了测试的不同之处。

               例如：testGetAuthAddress()、testGetAuthAddressWithWxErrorException()、
                    testCreateAppBindRelations()、testCreateAppBindRelationsWithRepeatedException()。

          7.  使用AssertJ断言代替Junit和Hamcrest的断言，因为AssertJ使用流式的方式组织断言，提高测试代码的可读性对IDE更加友好。比如：

               将assertEquals(var1,var2)    换为   assertThat(val1).isEqualTo(val2)；

               将assertThat("myStringOfNote", containsString("ring"))   换为   assertThat("myStringOfNote").contains("ring")

          8.  每条断言需加上describe用于快速判断断言失败原因。

          9.  每条测试用例需对mock方法进行verify，以确保测试逻辑按指定方式执行，并不是恰巧得到正确结果。

          10.  使用DisplayName和Nested注解将每个被测试类进行分层和描述，有助于理解测试报告：

          11.  单元测试代码应符合所有代码开发规范。包括所有语法警告、重复代码、魔法值等规范。

---
###四 、目标


         代码覆盖率是测试范围的有用指标，但代码测试覆盖率本身不应该被视为目标。

         1. 带来比功能测试更高的测试覆盖率

             根据我们的经验，功能测试只可以覆盖大约70%的应用程序代码。单元测试可以很容易的模拟错误条件，这点在功能测试中却很难办到（在某些情况下是不可能办到的）。

         2. 检测衰退和减少调试

             一个成功通过的单元测试集可以确认你的代码能够正常运行，同时也给予你修改现有代码的信心，要么是为了重构的目的，要么是为了增加或修改新的特性。作为开发者，没有什么比这个感觉更好了：知道有人

             正站在背后看着你，而且如果你有什么做得不对的地方还会及时提醒你。

          3. 将预期的行为文档化

              假设你需要学习一个新的API。一边是花300页描述你这个API的文档，而另一边是描述如何使用这几个API的实例，那么你会如何选择？

              示例的威力是众所周知的。单元测试恰恰就是这样的示例：它们展示了如何使用这个API。也正因为如此，它们是完美的开发文档。因为单元测试必须与工作代码保持同步，所以不像其他形式的文档，单元测试必须始终是最新的。



          以上的目标都是需要长期观察验证的，在验证的道路上发现问题，需要及时讨论并调整测试方案及规范。